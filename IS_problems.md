**Зад.1.** Да се напише функция **replicate'**, която конструира списък от n повторения на даден обект:
```Haskell
replicate' 5 10 -> [10,10,10,10,10]
```
**Зад.2.** Използвайте _foldr_ или _foldl_, за да напишете следните функции:
- minimum'/maximum'
- reverse'
- length'
- all'/any'
- append'
- replicate'
- makeSet' (вж. по-долу)

**Зад.3.** Използвайте *list comprehension*, за да напишете следните функции:
- брой/сума на делителите на дадено число
- проверка дали дадено число е просто
- descartes - декартово произведение на два списъка

**Зад.4.** Да се генерира безкрайния списък **primes** от прости числа:
```Haskell
take 5 primes -> [2,3,5,7,9]
```
**Зад.5\***. Да се генерира безкрайния списък от прости числа по метода на ситото на Ератостен.

**Зад.6.** Да се генерира безкраен списък, който съдържа всички наредени двойки от естествени числа.
Упътване: какъв резултат ще върне извикването на `elemIndex (2,3)` върху Вашия списък?

**Зад.7.** Да се генерира безкраен списък, който съдържа всички Питагорови тройки: наредени тройки от естествени числа, които могат да бъдат страни на правоъгълен триъгълник

**Зад.8.** Да се напише функция **compress**, която по списък от стойности връща списък от наредени двойки от вида (<стойност>, <брой последователни срещания>):
```Haskell
compress [1,1,2,3,3,3,4,2,2,2,2,1] -> [(1,2),(2,1),(3,3),(4,1),(2,4),(1,1)]
compress "abba" -> [('a',1),('b',2),('a',1)]
```
**Зад.9.** Да се напише функция **maxRepeated**, която по списък от стойности връща дължината на най-дългия подсписък, съставен от еднакви стойности:
```Haskell
maxRepeated [1,1,2,3,3,3,4,2,2,2,2,1,1] -> 4
```
**Зад.10.** Да се напише функция **makeSet**, която по даден списък връща всички негови уникални елементи (редът им няма значение):
```Haskell
makeSet [1,1,2,3,3,3,4,2,2,2,1,1] -> [1,2,3,4]
makeSet "abba" -> "ab"
```
**Зад.11.** Да се напише функция **histogram**, която за всяка уникална стойност от даден списък връща списък от наредени двойки от вида (<стойност>, <общ брой срещания>):
```Haskell
histogram [1,1,2,3,3,3,4,2,2,2,1,1] -> [(1,4),(2,4),(3,3),(4,1)]
```
**Зад.12.** Да се напише функция **maxDistance**, която получава списък от точки (наредени двойки (Double, Double)) и връща дължината на най-дългата отсечка между някои две от тях.
```Haskell
maxDistance [(-1.1, 1), (1.8, 2), (3, 1), (-1, -2)] -> 5.0
```
**Зад.13.** Да се напише функцията **sumProducts**, която приема списък от списъци от числа и връща сумата на всички произведения на числата в даден списък:
```Haskell
sumProducts [[1,2,3], [4,5], [], [-2,3,0,5,1]] -> 27 -- 27 = 6 + 20 + 1 + 0
```
**Зад.14.** Да се напише функцията **occurrences**, която приема два списъка от числа и връща списък от броя срещания на елементите от първия списък във втория:
```Haskell
occurrences [1..6] [1,3,4,3,2,3,3,0,5,3,1] -> [2,1,5,1,1,0]
```
**Зад.15.** Да се напише функцията **matchLengths**, която проверява дали всички списъци от списък със списъци са с еднаква дължина:
```Haskell
matchLengths [[1..4],[0..3],[5,4,8,10]] -> True
matchLengths [[1..4],[0..3],[],[5,4,8,10]] -> False
```
**Зад.16.** За тази задача ще представяме множествата като наредени списъци от своите елементи (значи те трябва да могат да бъдат сравнявани с == и < и да се срещат точно по веднъж). Да се напишат функции **setUnion**, **setIntersect** и **setDiff**, които намират съответно обединението, сечението и разликата на две множества:
```Haskell
setUnion [1,2,3,5] [2,4,5,6,7] -> [1,2,3,4,5,6,7]
setIntersect [1,2,3,5] [2,4,5,6,7] -> [2,5]
setDiff [1,2,3,5] [2,4,5,6,7] -> [1,3]
setDiff [2,4,5,6,7] [1,2,3,5] -> [4,6,7]
```
**Зад.17\*.** Нека е дадена квадратна матрица от числа. Под “Гаусова елиминация” ще разбираме операцията, при която се избира първият ред отгоре надолу, в който първият елемент е ненулев, и към всеки друг ред на матрицата прибавяме избрания ред, умножен по такъв коефициент, че числата в първия стълб на тези редове да станат равни на нула:
```Haskell
[[ 0,3,5,0],     [[0, 3,5,0],
 [ 1,5,2,1],  ->  [1, 5,2,1],
 [ 2,3,8,4],      [0,-7,4,2], -- получено от (ред2 * (-2)) + ред2
 [-2,0,4,5]]      [0,10,8,7]] -- получено от (ред2 * 2) + ред3
```
Напишете функция **row_reduce**, която извършва тази операция. Можете да допуснете, че в първия стълб на матрицата има поне един ненулев елемент.

**Зад.18\*.** Напишете функция, която изчислява детерминантата на дадена квадратна матрица.

**Зад.19.** Напишете функция **cross_out**, която по дадена матрица от числа m с размери M\*N генерира всички M\*N на брой матрици, които могат да се получат от m със задраскване на някой ред и някой стълб. Редът на върнатите матрици няма значение.
Пример:
```Haskell
cross_out [[1,2,3,4],
           [5,6,7,8],
           [9,0,1,2]]
-> [ [[6,7,8],  [[5,7,8],  [[5,6,8],  [[5,6,7],  [[2,3,4],
      [0,1,2]],  [9,1,2]],  [9,0,2]],  [9,0,1]],  [0,1,2]], ... ]
-- и още 7 малки матрици
```
**Зад.20\*.** Да се напише функция **specialSort**, която приема като параметър списък от списъци и го сортира относно най-често срещания елемент във всеки от вътрешните списъци. Ако има няколко най-често срещани елемента, да се избира най-големия от тях:
```Haskell
specialSort ["moo", "bee", "eve", "abracadabra", "abcdefg", "mama", "z"]
  -> ["abracadabra", "bee", "eve", "abcdefg", "mama", "moo", "z"]
-- в случая най-често срещаните елементи са съответно 'a', 'e', 'e', 'g', 'm', 'o', 'z'
-- наредбата не е уникална - няма проблем с това, нямаме изисквания за стабилност
```
